<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <title>ns-3 Change Log</title>
</head>
<body>

<h1>
ns-3: API and model change history</h1>
<!--
This ChangeLog is updated in the reverse order 
with the most recent changes coming first.  Date format:  DD-MM-YYYY
-->
<p>
ns-3 is an evolving system and there will be API or behavioral changes
from time to time.   Users who try to use scripts or models across
versions of ns-3 may encounter problems at compile time, run time, or
may see the simulation output change.  </p>
<p>
We have adopted the development policy that we are going to try to ease
the impact of these changes on users by documenting these changes in a
single place (this file), and not by providing a temporary or permanent
backward-compatibility software layer.  </p>
<p>
The goal is that users who encounter a problem when trying to use older
code with newer code should be able to consult this file to find
guidance as to how to fix the problem.  For instance, if a method name
or signature has changed, it should be stated what the new replacement
name is. </p>
<p>
Note that users who upgrade the simulator across versions, or who work
directly out of the development tree, may find that simulation output
changes even when the compilation doesn't break, such as when a
simulator default value is changed.  Therefore, it is good practice for
_anyone_ using code across multiple ns-3 releases to consult this file,
as well as the RELEASE_NOTES, to understand what has changed over time.
</p>
<p>
This file is a best-effort approach to solving this issue; we will do
our best but can guarantee that there will be things that fall through
the cracks, unfortunately.  If you, as a user, can suggest improvements
to this file based on your experience, please contribute a patch or drop
us a note on ns-developers mailing list.  </p>

<hr>
<h1>Changes from ns-3.4 to ns-3.5</h1>

<h2>Changes to build system:</h2>
<ul>
</ul>

<h2>New API:</h2>

<ul>
<li><b>YansWifiPhyHelper supporting radiotap and prism PCAP output</b>
<p>The newly supported pcap formats can be adopted by calling the following new method of YansWifiPhyHelper:</p>
<pre>
 +  void SetPcapFormat (enum PcapFormat format);
</pre>
where format is one of PCAP_FORMAT_80211_RADIOTAP, PCAP_FORMAT_80211_PRISM or  PCAP_FORMAT_80211. By default, PCAP_FORMAT_80211 is used, so the default PCAP format is the same as before.</p>
</li>

<li> <b>attributes for class Ipv4</b>
<p> class Ipv4 now contains attributes in ipv4.cc; the first one
is called "IpForward" that will enable/disable Ipv4 forwarding.  
</li>

<li> <b>packet tags</b>
<p>class Packet now contains AddPacketTag, RemovePacketTag and PeekPacketTag 
which can be used to attach a tag to a packet, as opposed to the old 
AddTag method which attached a tag to a set of bytes. The main 
semantic difference is in how these tags behave in the presence of 
fragmentation and reassembly.
</li>

</ul>

<h2>Changes to existing API:</h2>
<ul>

<li><b>CreateObject changes</b>
  <p>CreateObject is now able to construct objects with a non-default constructor.
   If you used to pass attribute lists to CreateObject, you must now use CreateObjectWithAttributes.
  </p>
</li>

<li> <b>packet byte tags renaming</b>
  <ul>
  <li>Packet::AddTag to Packet::AddByteTag</li>
  <li>Packet::FindFirstMatchingTag to Packet::FindFirstMatchingByteTag</li>
  <li>Packet::RemoveAllTags to Packet::RemoveAllByteTags</li>
  <li>Packet::PrintTags to Packet::PrintByteTags</li>
  <li>Packet::GetTagIterator to Packet::GetByteTagIterator</li>
  </ul>
</li>

<li><b>YansWifiPhyHelper::EnablePcap* methods not static any more</b>
<p>To accommodate the possibility of configuring the PCAP format used for wifi promiscuous mode traces, several methods of YansWifiPhyHelper had to be made non-static:
<pre>
-  static void EnablePcap (std::string filename, uint32_t nodeid, uint32_t deviceid);
+         void EnablePcap (std::string filename, uint32_t nodeid, uint32_t deviceid);
-  static void EnablePcap (std::string filename, Ptr<NetDevice> nd);
+         void EnablePcap (std::string filename, Ptr<NetDevice> nd);
-  static void EnablePcap (std::string filename, std::string ndName);
+         void EnablePcap (std::string filename, std::string ndName);
-  static void EnablePcap (std::string filename, NetDeviceContainer d);
+         void EnablePcap (std::string filename, NetDeviceContainer d);
-  static void EnablePcap (std::string filename, NodeContainer n);
+         void EnablePcap (std::string filename, NodeContainer n);
-  static void EnablePcapAll (std::string filename);
+         void EnablePcapAll (std::string filename);
</pre>
</p>
</li>

<li><b>Wifi Promisc Sniff interface modified </b>
<p> 
To accommodate support for the radiotap and prism headers in PCAP traces, the interface for promiscuos mode sniff in the wifi device was changed. The new implementation was heavily inspired by the way the madwifi driver handles monitor mode. A distinction between TX and RX events is introduced, to account for the fact that different information is to be put in the radiotap/prism header (e.g., RSSI and noise make sense only for RX packets). The following are the relevant modifications to the WifiPhy class:
<pre>
-  void NotifyPromiscSniff (Ptr<const Packet> packet);
+  void NotifyPromiscSniffRx (Ptr<const Packet> packet, uint16_t channelFreqMhz, uint32_t rate, bool isShortPreamble, double signalDbm, double noiseDbm);
+  void NotifyPromiscSniffTx (Ptr<const Packet> packet, uint16_t channelFreqMhz, uint32_t rate, bool isShortPreamble);
-  TracedCallback<Ptr<const Packet> > m_phyPromiscSnifferTrace;
+  TracedCallback<Ptr<const Packet>, uint16_t, uint32_t, bool, double, double> m_phyPromiscSniffRxTrace;
+  TracedCallback<Ptr<const Packet>, uint16_t, uint32_t, bool> m_phyPromiscSniffTxTrace;
</pre>
The above mentioned callbacks are expected to be used to call the following method to write Wifi PCAP traces in promiscuous mode:
<pre>
+  void WriteWifiMonitorPacket(Ptr<const Packet> packet, uint16_t channelFreqMhz, uint32_t rate, bool isShortPreamble, bool isTx, double signalDbm, double noiseDbm);
</pre>
In the above method, the isTx parameter is to be used to differentiate between TX and RX packets. For an example of how to implement these callbacks, see the implementation of PcapSniffTxEvent and PcapSniffRxEvent in src/helper/yans-wifi-helper.cc
</p>
</li>

<li><b> Routing decoupled from class Ipv4</b>
<p> All calls of the form "Ipv4::AddHostRouteTo ()" etc. (i.e. to 
add static routes, both unicast and multicast) have been moved to a new 
class Ipv4StaticRouting.  In addition, class Ipv4 now holds only
one possible routing protocol; the previous way to add routing protocols
(by ordered list of priority) has been moved to a new class Ipv4ListRouting.
Class Ipv4 has a new minimal routing API (just to set and get the routing
protocol):
<pre>
-  virtual void AddRoutingProtocol (Ptr&lt;Ipv4RoutingProtocol&gt; routingProtocol, int16_t priority) = 0;
+  virtual void SetRoutingProtocol (Ptr&lt;Ipv4RoutingProtocol&gt; routingProtocol) = 0;
+  virtual Ptr&lt;Ipv4RoutingProtocol&gt; GetRoutingProtocol (void) const = 0;
</pre>
</li>

<li><b> class Ipv4RoutingProtocol is refactored</b>
<p> The abstract base class Ipv4RoutingProtocol has been refactored to
align with corresponding Linux Ipv4 routing architecture, and has been
moved from ipv4.h to a new file ipv4-routing-protocol.h.  The new
methods (RouteOutput () and RouteInput ()) are aligned with Linux 
ip_route_output() and ip_route_input().  However,
the general nature of these calls (synchronous routing lookup for
locally originated packets, and an asynchronous, callback-based lookup
for forwarded packets) is still the same.
<pre>
-  typedef Callback&lt;void, bool, const Ipv4Route&, Ptr&lt;Packet&gt;, const Ipv4Header&&gt; RouteReplyCallback;
+  typedef Callback&lt;void, Ptr&lt;Ipv4Route&gt;, Ptr&lt;const Packet&gt;, const Ipv4Header &&gt; UnicastForwardCallback;
+  typedef Callback&lt;void, Ptr&lt;Ipv4MulticastRoute&gt;, Ptr&lt;const Packet&gt;, const Ipv4Header &&gt; MulticastForwardCallback;
+  typedef Callback&lt;void, Ptr&lt;const Packet&gt;, const Ipv4Header &, uint32_t &gt; LocalDeliverCallback;
+  typedef Callback&lt;void, Ptr&lt;const Packet&gt;, const Ipv4Header &&gt; ErrorCallback;
-  virtual bool RequestInterface (Ipv4Address destination, uint32_t& interface) = 0;
+  virtual Ptr&lt;Ipv4Route&gt; RouteOutput (const Ipv4Header &header, uint32_t oif, Socket::SocketErrno &errno) = 0;
-  virtual bool RequestRoute (uint32_t interface,
-                            const Ipv4Header &ipHeader,
-                            Ptr&lt;Packet&gt; packet,
-                            RouteReplyCallback routeReply) = 0;
+  virtual bool RouteInput  (Ptr&lt;const Packet&gt; p, const Ipv4Header &header, Ptr&lt;const NetDevice&gt; idev,
+                             UnicastForwardCallback ucb, MulticastForwardCallback mcb,
+                             LocalDeliverCallback lcb, ErrorCallback ecb) = 0;
</pre>

</li>
<li><b> previous class Ipv4Route, Ipv4MulticastRoute renamed; new classes with
those same names added</b>
<p> The previous class Ipv4Route and Ipv4MulticastRoute are used by 
Ipv4StaticRouting and Ipv4GlobalRouting to record internal routing table
entries, so they were renamed to class Ipv4RoutingTableEntry and
Ipv4MulticastRoutingTableEntry, respectively.  In their place, new
class Ipv4Route and class Ipv4MulticastRoute have been added.  These
are reference-counted objects that are analogous to Linux struct
rtable and struct mfc_cache, respectively, to achieve better compatibility
with Linux routing architecture in the future.  

<li><b> class Ipv4 address-to-interface mapping functions changed</b>
<p>  There was some general cleanup of functions that involve mappings
from Ipv4Address to either NetDevice or Ipv4 interface index.  
<pre>
-  virtual uint32_t FindInterfaceForAddr (Ipv4Address addr) const = 0;
-  virtual uint32_t FindInterfaceForAddr (Ipv4Address addr, Ipv4Mask mask) const = 0;
+  virtual int32_t GetInterfaceForAddress (Ipv4Address address) const = 0;
+  virtual int32_t GetInterfaceForPrefix (Ipv4Address address, Ipv4Mask mask) const = 0;
-  virtual int32_t FindInterfaceForDevice(Ptr&lt;NetDevice&gt; nd) const = 0;
+  virtual int32_t GetInterfaceForDevice (Ptr&lt;const NetDevice&gt; device) const = 0;
-  virtual Ipv4Address GetSourceAddress (Ipv4Address destination) const = 0;
-  virtual bool GetInterfaceForDestination (Ipv4Address dest,
-  virtual uint32_t GetInterfaceByAddress (Ipv4Address addr, Ipv4Mask mask = Ipv4Mask("255.255.255.255"));
</pre>

<li><b> class Ipv4 multicast join API deleted</b>
<p> The following methods are not really used in present form since IGMP
is not being generated, so they have been removed (planned to be replaced
by multicast socket-based calls in the future):

<pre>
- virtual void JoinMulticastGroup (Ipv4Address origin, Ipv4Address group) = 0;
- virtual void LeaveMulticastGroup (Ipv4Address origin, Ipv4Address group) = 0;
</pre>


<li><b>Deconflict NetDevice::ifIndex and Ipv4::ifIndex (bug 85).</b>
<p>All function parameters named "ifIndex" that refer 
to an Ipv4 interface are instead named "interface".
<pre>
- static const uint32_t Ipv4RoutingProtocol::IF_INDEX_ANY = 0xffffffff;
+ static const uint32_t Ipv4RoutingProtocol::INTERFACE_ANY = 0xffffffff;

- bool Ipv4RoutingProtocol::RequestIfIndex (Ipv4Address destination, uint32_t& ifIndex);
+ bool Ipv4RoutingProtocol::RequestInterface (Ipv4Address destination, uint32_t& interface);
(N.B. this particular function is planned to be renamed to RouteOutput() in the
proposed IPv4 routing refactoring)

- uint32_t Ipv4::GetIfIndexByAddress (Ipv4Address addr, Ipv4Mask mask);
+ int_32t Ipv4::GetInterfaceForAddress (Ipv4Address address, Ipv4Mask mask) const;

- bool Ipv4::GetIfIndexForDestination (Ipv4Address dest, uint32_t &ifIndex) const;
+ bool Ipv4::GetInterfaceForDestination (Ipv4Address dest, uint32_t &interface) const;
(N.B. this function is not needed in the proposed Ipv4 routing refactoring)
</pre>


<li><b>Allow multiple IPv4 addresses to be assigned to an interface (bug 188)</b>
  <ul>
  <li> Add class Ipv4InterfaceAddress:  
  This is a new class to resemble Linux's struct in_ifaddr.  It holds IP addressing information, including mask,
  broadcast address, scope, whether primary or secondary, etc.
  <pre>
+  virtual uint32_t AddAddress (uint32_t interface, Ipv4InterfaceAddress address) = 0;
+  virtual Ipv4InterfaceAddress GetAddress (uint32_t interface, uint32_t addressIndex) const = 0;
+  virtual uint32_t GetNAddresses (uint32_t interface) const = 0;
  </pre>
  <li>Regarding legacy API usage, typically where you once did the following,
  using the public Ipv4 class interface (e.g.):
  <pre>
  ipv4A->SetAddress (ifIndexA, Ipv4Address ("172.16.1.1"));
  ipv4A->SetNetworkMask (ifIndexA, Ipv4Mask ("255.255.255.255"));
  </pre>
  you now do:
  <pre>
  Ipv4InterfaceAddress ipv4IfAddrA = Ipv4InterfaceAddress (Ipv4Address ("172.16.1.1"), Ipv4Mask ("255.255.255.255"));
  ipv4A->AddAddress (ifIndexA, ipv4IfAddrA);
  </pre>
  <li> At the helper API level, one often gets an address from an interface
  container.  We preserve the legacy GetAddress (uint32_t i) but it
  is documented that this will return only the first (address index 0)
  address on the interface, if there are multiple such addresses. 
  We provide also an overloaded variant for the multi-address case: 

  <pre>
Ipv4Address Ipv4InterfaceContainer::GetAddress (uint32_t i)
+ Ipv4Address Ipv4InterfaceContainer::GetAddress (uint32_t i, uint32_t j)
  </pre>

  </ul>

<li><b>New WifiMacHelper objects</b>
<p>The type of wifi MAC is now set by two new specific helpers, NqosWifiMacHelper for non QoS MACs and QosWifiMacHelper for Qos MACs. They are passed as argument to WifiHelper::Install methods.</li>
  <pre>
- void WifiHelper::SetMac (std::string type, std::string n0 = "", const AttributeValue &v0 = EmptyAttributeValue (),...)

- NetDeviceContainer WifiHelper::Install (const WifiPhyHelper &phyHelper, NodeContainer c) const
+ NetDeviceContainer WifiHelper::Install (const WifiPhyHelper &phyHelper, const WifiMacHelper &macHelper, NodeContainer c) const

- NetDeviceContainer WifiHelper::Install (const WifiPhyHelper &phy, Ptr&lt;Node&gt; node) const
+ NetDeviceContainer WifiHelper::Install (const WifiPhyHelper &phy, const WifiMacHelper &mac, Ptr&lt;Node&gt; node) const

- NetDeviceContainer WifiHelper::Install (const WifiPhyHelper &phy, std::string nodeName) const
+ NetDeviceContainer WifiHelper::Install (const WifiPhyHelper &phy, const WifiMacHelper &mac, std::string nodeName) const
  </pre>
  See src/helper/nqos-wifi-mac-helper.h and src/helper/qos-wifi-mac-helper.h for more details.
  </p>

<li><b>Remove Mac48Address::IsMulticast</b>
  <p>This method was considered buggy and unsafe to call. Its replacement is Mac48Address::IsGroup.
  </li>

</ul>

<h2>Changed behavior:</h2>
<ul>
</ul>

<hr>
<h1>Changes from ns-3.3 to ns-3.4</h1>

<h2>Changes to build system:</h2>
<ul>
<li>A major option regarding the downloading and building of ns-3 has been
added for ns-3.4 -- the ns-3-allinone feature.  This allows a user to
get the most common options for ns-3 downloaded and built with a minimum
amount of trouble.  See the ns-3 tutorial for a detailed explanation of
how to use this new feature.</li>

<li>The build system now runs build items in parallel by default.  This includes
the regression tests.</li>
</ul>

<h2>New API:</h2>
<ul>
<li>XML support has been added to the ConfigStore in /src/contrib/config-store.cc</li>

<li>The ns-2 calendar queue scheduler option has been ported to src/simulator</li>

<li>A ThreeLogDistancePropagationLossModel has been added to src/devices/wifi</li>

<li>ConstantAccelerationMobilityModel in src/mobility/constant-acceleration-mobility-model.h</li>

<li>A new emulation mode is supported with the TapBridge net device (see
src/devices/tap-bridge)</li>

<li>A new facility for naming ns-3 Objects is included (see
src/core/names.{cc,h})</li>

<li>Wifi multicast support has been added in src/devices/wifi</li>
</ul>

<h2>Changes to existing API:</h2>

<ul>
<li>Some fairly significant changes have been made to the API of the
random variable code.  Please see the ns-3 manual and src/core/random-variable.cc
for details.</li>

<li>The trace sources in the various NetDevice classes has been completely
reworked to allow for a consistent set of trace sources across the
devices.  The names of the trace sources have been changed to provide
some context with respect to the level at which the trace occurred.
A new set of trace sources has been added which emulates the behavior
of packet sniffers.  These sources have been used to implement tcpdump-
like functionality and are plumbed up into the helper classes.  The 
user-visible changes are the trace source name changes and the ability
to do promiscuous-mode pcap tracing via helpers.  For further information
regarding these changes, please see the ns-3 manual</li>

<li>StaticMobilityModel has been renamed ConstantPositionMobilityModel
StaticSpeedMobilityModel has been renamed ConstantVelocityMobilityModel</li>

<li>The Callback templates have been extended to support more parameters.
See src/core/callback.h</li>

<li>Many helper API have been changed to allow passing Object-based parameters
as string names to ease working with the object name service.</li>

<li>The Config APIs now accept path segments that are names defined by the
object name service.</li>

<li>Minor changes were made to make the system build under the Intel C++ compiler.</li>

<li>Trace hooks for association and deassociation to/from an access point were
added to src/devices/wifi/nqsta-wifi-mac.cc</li>
</ul>

<h2>Changed behavior:</h2>

<ul>
<li>The tracing system rework has introduced some significant changes in the
behavior of some trace sources, specifically in the positioning of trace sources
in the device code.  For example, there were cases where the packet transmit 
trace source was hit before the packet was enqueued on the device transmit quueue.
This now happens just before the packet is transmitted over the channel medium.
The scope of the changes is too large to be included here.  If you have concerns
regarding trace semantics, please consult the net device documentation for details.
As is usual, the ultimate source for documentation is the net device source code.</li>
</ul>

<hr>
<h1>Changes from ns-3.2 to ns-3.3</h1>

<h2>New API:</h2>
<ul>
<li>
ns-3 ABORT macros in src/core/abort.h
Config::MatchContainer
ConstCast and DynamicCast helper functions for Ptr casting
StarTopology added to several topology helpers
NetDevice::IsBridge () 
</li>

<li>17-11-2008; changeset 
<a href="http://code.nsnam.org/ns-3-dev/rev/4c1c3f6bcd03">4c1c3f6bcd03</a></li>
<ul>
<li>
The PppHeader previously defined in the point-to-point-net-device code has been 
made public.
</li>
</ul>

<li>17-11-2008; changeset 
<a href="http://code.nsnam.org/ns-3-dev/rev/16c2970a0344">16c2970a0344</a></li>
<ul>
<li>
An emulated net device has been added as enabling technology for ns-3 emulation
scenarios.  See src/devices/emu and examples/emu-udp-echo.cc for details.
</li>
</ul>

<li>17-11-2008; changeset 
<a href="http://code.nsnam.org/ns-3-dev/rev/4222173d1e6d">4222173d1e6d</a></li>
<ul>
<li>
Added method InternetStackHelper::EnableAsciiChange to allow allow a user to 
hook ascii trace to the drop trace events in Ipv4L3Protocol and ArpL3Protocol.
</li>
</ul>

</ul>
<h2>Changes to existing API:</h2>
<ul>

<li> NetDevice::MakeMulticastAddress() was renamed to NetDevice::GetMulticast()
and the original GetMulticast() removed </li>

<li> Socket API changes:
<ul>
<li> return type of SetDataSentCallback () changed from bool to void </li>
<li> Socket::Listen() no longer takes a queueLimit argument</li>
</ul>

<li> As part of the Wifi Phy rework, there have been several API changes
at the low level and helper API level.  </li>
<ul>
<li>  At the helper API level, the WifiHelper was split to three classes: 
a WifiHelper, a YansWifiChannel helper, and a YansWifiPhy helper.  Some
functions like Ascii and Pcap tracing functions were moved from class
WifiHelper to class YansWifiPhyHelper. 
<li>  At the low-level API, there have been a number of changes to
make the Phy more modular:</li>
<ul>
<li> composite-propagation-loss-model.h is removed</li>
<li> DcfManager::NotifyCcaBusyStartNow() has changed name</li>
<li> fragmentation related functions (e.g. DcaTxop::GetNFragments()) have
changed API to account for some implementation changes</li>
<li> Interference helper and error rate model added </li>
<li> JakesPropagationLossModel::GetLoss() moved to PropagationLoss() class</li>
<li> base class WifiChannel made abstract </li>
<li> WifiNetDevice::SetChannel() removed </li>
<li> a WifiPhyState helper class added </li>
<li> addition of the YansWifiChannel and YansWifiPhy classes </li>
</ul>
</ul>

<li>17-11-2008; changeset 
<a href="http://code.nsnam.org/ns-3-dev/rev/dacfd1f07538">dacfd1f07538</a></li>
<ul>
<li>
Change attribute "RxErrorModel" to "ReceiveErrorModel" in CsmaNetDevice for 
consistency between devices.
</li>
</ul>

</ul>
<h2>changed behavior:</h2>
<ul>

<li>17-11-2008; changeset 
<a href="http://code.nsnam.org/ns-3-dev/rev/ed0dfce40459">ed0dfce40459</a></li>
<ul>
<li>
Relax reasonableness testing in Ipv4AddressHelper::SetBase to allow the 
assignment of /32 addresses.
</li>
</ul>

<li>17-11-2008; changeset 
<a href="http://code.nsnam.org/ns-3-dev/rev/756887a9bbea">756887a9bbea</a></li>
<ul>
<li>
Global routing supports bridge devices.
</li>
</ul>
</ul>

<hr>
<h1>Changes from ns-3.1 to ns-3.2</h1>

<h2>New API:</h2>
<ul>

<li>26-08-2008; changeset 
<a href="http://code.nsnam.org/ns-3-dev/rev/5aa65b1ea001">5aa65b1ea001</a></li>
<ul>
<li>
Add multithreaded and real-time simulator implementation.  Allows for emulated
net devices running in threads other than the main simulation thread to schedule
events.  Allows for pacing the simulation clock at 1x real-time.
</li>
</ul>


<li>26-08-2008; changeset 
<a href="http://code.nsnam.org/ns-3-dev/rev/c69779f5e51e">c69779f5e51e</a></li>
<ul>
<li>
Add threading and synchronization primitives.  Enabling technology for 
multithreaded simulator implementation.
</li>
</ul>

</ul>
<h2>New API in existing classes:</h2>
<ul>

<li>01-08-2008; changeset 
<a href="http://code.nsnam.org/ns-3-dev/rev/a18520551cdf">a18520551cdf</a></li>
<ul>
<li>class ArpCache has two new attributes:  MaxRetries 
and a Drop trace.  It also has some new public methods but these are 
mostly for internal use.
</ul>
</li>

</ul>
<h2>Changes to existing API:</h2>
<ul>

<li>05-09-2008; changeset 
<a href="http://code.nsnam.org/ns-3-dev/rev/aa1fb0f43571">aa1fb0f43571</a></li>
<ul>
<li>
Change naming of MTU and packet size attributes in CSMA and Point-to-Point devices<br>
After much discussion it was decided that the preferred way to think about 
the different senses of transmission units and encapsulations was to call the 
MAC MTU simply MTU and to use the overall packet size as the PHY-level attribute
of interest.  See the Doxygen of CsmaNetDevice::SetFrameSize and 
PointToPointNetDevice::SetFrameSize for a detailed description.
</li>
</ul>

<li>25-08-2008; changeset 
<a href="http://code.nsnam.org/ns-3-dev/rev/e5ab96db540e">e5ab96db540e</a></li>
<ul>
<li>
bug 273: constify packet pointers.<br>
The normal and the promiscuous receive callbacks of the NetDevice API
have been changed from:
<pre>
Callback<bool,Ptr<NetDevice>,Ptr<Packet>,uint16_t,const Address &>
Callback<bool,Ptr<NetDevice>, Ptr<Packet>, uint16_t,
         const Address &, const Address &, enum PacketType >
</pre>
to:
<pre>
Callback<bool,Ptr<NetDevice>,Ptr<const Packet>,uint16_t,const Address &>
Callback<bool,Ptr<NetDevice>, Ptr<const Packet>, uint16_t,
         const Address &, const Address &, enum PacketType >
</pre>
to avoid the kind of bugs reported in 
<a href="http://www.nsnam.org/bugzilla/show_bug.cgi?id=273">bug 273</a>.
Users who implement a subclass of the NetDevice base class need to change the signature
of their SetReceiveCallback and SetPromiscReceiveCallback methods.
</li>
</ul>


<li>04-08-2008; changeset 
<a href="http://code.nsnam.org/ns-3-dev/rev/cba7b2b80fe8">cba7b2b80fe8</a></li>
<ul>
<li>
Cleanup of MTU confusion and initialization in CsmaNetDevice<br>
The MTU of the CsmaNetDevice defaulted to 65535.  This did not correspond with
the expected MTU found in Ethernet-like devices.  Also there was not clear 
documentation regarding which MTU was being set.  There are two MTU here, one
at the MAC level and one at the PHY level.  We split out the MTU setting to make
this more clear and set the default PHY level MTU to 1500 to be more like
Ethernet.  The encapsulation mode defaults to LLC/SNAP which then puts the
MAC level MTU at 1492 by default.  We allow users to now set the encapsulation
mode, MAC MTU and PHY MTU while keeping the three values consistent.  See the
Doxygen of CsmaNetDevice::SetMaxPayloadLength for a detailed description of the
issues and solution.
</li>
</ul>

<li>21-07-2008; changeset 
<a href="
http://code.nsnam.org/ns-3-dev/rev/99698bc858e8">99698bc858e8</a></li>
<ul>
<li> class NetDevice has added a pure virtual method that
must be implemented by all subclasses:
<pre>
virtual void SetPromiscReceiveCallback (PromiscReceiveCallback cb) = 0;
</pre>
All NetDevices must support this method, and must call this callback
when processing packets in the receive direction (the appropriate place
to call this is device-dependent).  An approach to stub this out
temporarily, if you do not care about immediately enabling this
functionality, would be to add this to your device:
<pre>
void
ExampleNetDevice::SetPromiscReceiveCallback
(NetDevice::PromiscReceiveCallback cb)
{ 
  NS_ASSERT_MSG (false, "No implementation yet for
SetPromiscReceiveCallback");
}
</pre>
To implement this properly, consult the CsmaNetDevice for examples of
when the m_promiscRxCallback is called.
</li>
</ul>

<li>03-07-2008; changeset 
<a href="http://code.nsnam.org/ns-3-dev/rev/d5f8e5fae1c6">d5f8e5fae1c6</a></li>
<ul>
<li>
Miscellaneous cleanup of Udp Helper API, to fix bug 234
<pre>
class UdpEchoServerHelper
{
public:
- UdpEchoServerHelper ();
- void SetPort (uint16_t port); 
+ UdpEchoServerHelper (uint16_t port);
+ 
+ void SetAttribute (std::string name, const AttributeValue &value);
ApplicationContainer Install (NodeContainer c);

class UdpEchoClientHelper
{
public:
- UdpEchoClientHelper ();
+ UdpEchoClientHelper (Ipv4Address ip, uint16_t port);
- void SetRemote (Ipv4Address ip, uint16_t port);
- void SetAppAttribute (std::string name, const AttributeValue &value);
+ void SetAttribute (std::string name, const AttributeValue &value);
ApplicationContainer Install (NodeContainer c);
</pre>
</li>
</ul>

<li>03-07-2008; changeset 
<a href="
http://code.nsnam.org/ns-3-dev/rev/3cdd9d60f7c7">3cdd9d60f7c7</a></li>
<ul>
<li>
Rename all instances method names using "Set..Parameter" to "Set..Attribute"
(bug 232)
</li>
<li> How to fix your code:  Any use of helper API that was using a method
"Set...Parameter()" should be changed to read "Set...Attribute()".  e.g.
<pre>
- csma.SetChannelParameter ("DataRate", DataRateValue (5000000));
- csma.SetChannelParameter ("Delay", TimeValue (MilliSeconds (2)));
+ csma.SetChannelAttribute ("DataRate", DataRateValue (5000000));
+ csma.SetChannelAttribute ("Delay", TimeValue (MilliSeconds (2)));
</pre>
</li>
</ul>
</li>

</ul>
<h2>Changed behavior:</h2>
<ul>

<li>07-09-2008; changeset 
<a href="http://code.nsnam.org/ns-3-dev/rev/5d836ab1523b">5d836ab1523b</a></li>
<ul>

<li>
Implement a finite receive buffer for TCP<br>
The native TCP model in TcpSocketImpl did not support a finite receive buffer.
This changeset adds the following functionality in this regard:
<ul>
<li>
Being able to set the receiver buffer size through the attributes system.
</li>
<li>
This receiver buffer size is now correctly exported in the TCP header as the
advertised window.  Prior to this changeset, the TCP header advertised window
was set to the maximum size of 2^16 bytes.
window
</li>
<li>
The aforementioned window size is correctly used for flow control, i.e. the
sending TCP will not send more data than available space in the receiver's
buffer.
</li>
<li>
In the case of a receiver window collapse, when a advertised zero-window
packet is received, the sender enters the persist probing state in which
it sends probe packets with one payload byte at exponentially backed-off
intervals up to 60s.  The reciever will continue to send advertised 
zero-window ACKs of the old data so long as the receiver buffer remains full.
When the receiver window clears up due to an application read, the TCP
will finally ACK the probe byte, and update its advertised window appropriately.
</li>
</ul>
See 
<a href="http://www.nsnam.org/bugzilla/show_bug.cgi?id=239"> bug 239 </a> for
more.
</li>
</ul>

<li>07-09-2008; changeset 
<a href="http://code.nsnam.org/ns-3-dev/rev/7afa66c2b291">7afa66c2b291</a></li>
<ul>
<li>
Add correct FIN exchange behavior during TCP closedown<br>
The behavior of the native TcpSocketImpl TCP model was such that the final
FIN exchange was not correct, i.e. calling Socket::Close didn't send a FIN
packet, and even if it had, the ACK never came back, and even if it had, the
ACK would have incorrect sequence number.  All these various problems have been
addressed by this changeset.  See 
<a href="http://www.nsnam.org/bugzilla/show_bug.cgi?id=242"> bug 242 </a> for
more.
</li>
</ul>

<li> 28-07-2008; changeset 
<a href="http://code.nsnam.org/ns-3-dev/rev/6f68f1044df1">6f68f1044df1</a>
<ul>
<li>
OLSR: HELLO messages hold time changed to 3*hello
interval from hello interval.  This is an important bug fix as
hold time == refresh time was never intentional, as it leads to
instability in neighbor detection.
</ul>
</li>

</ul>

</body>
</html>
