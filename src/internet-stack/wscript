## -*- Mode: python; py-indent-offset: 4; indent-tabs-mode: nil; coding: utf-8; -*-
import Params
import os

# Mercurial repository of the network simulation cradle
NETWORK_SIMULATION_CRADLE_REPO = "https://secure.wand.net.nz/mercurial/nsc"
def nsc_fetch():
    def nsc_clone():
        print "Retrieving nsc from " + NETWORK_SIMULATION_CRADLE_REPO
        if os.system("hg version > /dev/null 2>&1") != 0:
            Params.fatal("Mercurial not installed, http fallback not yet implemented")
        if os.system("hg -q clone " + NETWORK_SIMULATION_CRADLE_REPO) != 0:
            Params.fatal("hg -q clone %s failed" % NETWORK_SIMULATION_CRADLE_REPO)

    def nsc_update():
        if os.system("hg version > /dev/null 2>&1") != 0:
            Params.warning("Mercurial not installed, not updating nsc source")

        print "Pulling nsc updates from " + NETWORK_SIMULATION_CRADLE_REPO
        if os.system("cd nsc && hg -q pull %s && hg -q update" % NETWORK_SIMULATION_CRADLE_REPO) != 0:
            Params.warning("Updating nsc using mercurial failed")

    if not os.path.exists("nsc"):
        nsc_clone()
    else:
        nsc_update()

def configure(conf):
    # checks for flex and bison, which is needed to build NSCs globaliser
    def check_nsc_buildutils():
        import flex
        import bison
        conf.check_tool('flex bison')
        e = conf.create_library_configurator()
        e.mandatory = True
        e.name = 'fl'
        e.run()

    if not Params.g_options.nsc:
        conf.report_optional_feature("nsc", "Network Simulation Cradle", False,
                                     "--nsc configure option not given")
	return

    check_nsc_buildutils()

    arch = os.uname()[4]
    ok = False
    if arch == 'x86_64' or arch == 'i686' or arch == 'i586' or arch == 'i486' or arch == 'i386':
        conf.env['NSC_ENABLED'] = 'yes'
        conf.define('NETWORK_SIMULATION_CRADLE', 1)
        conf.write_config_header('ns3/core-config.h')
        e = conf.create_library_configurator()
        e.mandatory = True
        e.name = 'dl'
        e.define = 'HAVE_DL'
        e.uselib = 'DL'
        e.run()
        ok = True
    conf.check_message('NSC supported architecture', arch, ok)
    conf.report_optional_feature("nsc", "Network Simulation Cradle", ok,
                                 "architecture %r not supported" % arch)
    nsc_fetch()


def build(bld):
    obj = bld.create_ns3_module('internet-stack', ['node'])
    obj.source = [
        'internet-stack.cc',
        'ipv4-l4-protocol.cc',
        'udp-header.cc',
        'tcp-header.cc',
        'ipv4-checksum.cc',
        'ipv4-interface.cc',
        'ipv4-l3-protocol.cc',
        'ipv4-static-routing.cc',
        'ipv4-end-point.cc',
        'udp-l4-protocol.cc',
        'tcp-l4-protocol.cc',
        'arp-header.cc',
        'arp-cache.cc',
        'arp-ipv4-interface.cc',
        'arp-l3-protocol.cc',
        'ipv4-loopback-interface.cc',
        'udp-socket-impl.cc',
        'tcp-socket-impl.cc',
        'ipv4-end-point-demux.cc',
        'ipv4-impl.cc',
        'udp-socket-factory-impl.cc',
        'tcp-socket-factory-impl.cc',
        'pending-data.cc',
        'sequence-number.cc',
        'rtt-estimator.cc',
        ]

    headers = bld.create_obj('ns3header')
    headers.module = 'internet-stack'
    headers.source = [
        'internet-stack.h',
        'udp-header.h',
        'tcp-header.h',
        'sequence-number.h',
        'ipv4-interface.h',
        'ipv4-l3-protocol.h',
        'ipv4-static-routing.h',
        ]

    if bld.env()['NSC_ENABLED']:
        obj.source.append ('nsc-tcp-socket-impl.cc')
        obj.source.append ('nsc-tcp-l4-protocol.cc')
        obj.source.append ('nsc-tcp-socket-factory-impl.cc')
        obj.source.append ('nsc-sysctl.cc')
        obj.uselib = 'DL'
